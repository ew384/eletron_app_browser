// ===== shared/types.ts å®Œæ•´æ›´æ–° =====
export interface BrowserAccount {
  id: string;
  name: string;
  status: 'idle' | 'running' | 'error';
  createdAt: number;
  config?: AccountConfig;
}

export interface BrowserInstance {
  accountId: string;
  windowId: number;
  status: 'starting' | 'running' | 'stopped';
  pid?: number;
  url?: string;
}

export interface AccountConfig {
  proxy?: string;
  userAgent?: string;
  fingerprint?: FingerprintConfig;
  behavior?: BehaviorConfig;
  cookies?: CookieConfig[];
  localStorage?: LocalStorageConfig;
}

export interface FingerprintConfig {
  canvas: CanvasFingerprintConfig;
  webgl: WebGLFingerprintConfig;
  audio: AudioFingerprintConfig;
  navigator: NavigatorFingerprintConfig;
  screen: ScreenFingerprintConfig;
  fonts: FontFingerprintConfig;
  timezone: TimezoneFingerprintConfig;
  webrtc?: WebRTCFingerprintConfig;
  battery?: BatteryFingerprintConfig;
}

export interface CanvasFingerprintConfig {
  noise: number;        // 0-1, å™ªå£°å¼ºåº¦
  enabled: boolean;
  seed?: number;        // å™ªå£°ç§å­
  algorithm: 'uniform' | 'gaussian' | 'perlin'; // å™ªå£°ç®—æ³•
}

export interface WebGLFingerprintConfig {
  vendor: string;
  renderer: string;
  enabled: boolean;
  unmaskedVendor?: string;
  unmaskedRenderer?: string;
  version?: string;
  shadingLanguageVersion?: string;
  extensions?: string[];
}

export interface AudioFingerprintConfig {
  noise: number;        // 0-1, å™ªå£°å¼ºåº¦
  enabled: boolean;
  seed?: number;
  sampleRate?: number;
  channelCount?: number;
  latency?: number;
}

export interface NavigatorFingerprintConfig {
  platform: string;
  language: string;
  languages: string[];
  hardwareConcurrency: number;
  maxTouchPoints: number;
  deviceMemory?: number;
  enabled: boolean;
  userAgent?: string;
  vendor?: string;
  vendorSub?: string;
  productSub?: string;
  appVersion?: string;
  cookieEnabled?: boolean;
  onLine?: boolean;
  javaEnabled?: boolean;
}

export interface ScreenFingerprintConfig {
  width: number;
  height: number;
  pixelRatio: number;
  colorDepth: number;
  enabled: boolean;
  availWidth?: number;
  availHeight?: number;
  orientation?: 'portrait' | 'landscape';
}

export interface FontFingerprintConfig {
  available: string[];
  enabled: boolean;
  measurementMethod: 'canvas' | 'dom';
}

export interface TimezoneFingerprintConfig {
  name: string;        // IANA timezone name
  offset: number;      // minutes from UTC
  enabled: boolean;
  dst?: boolean;       // daylight saving time
}

export interface WebRTCFingerprintConfig {
  enabled: boolean;
  localIPs: string[];
  publicIP?: string;
  blockICE?: boolean;
}

export interface BatteryFingerprintConfig {
  enabled: boolean;
  level: number;       // 0-1
  charging: boolean;
  chargingTime?: number;
  dischargingTime?: number;
}

export interface BehaviorConfig {
  mouseMovement?: MouseBehaviorConfig;
  typing?: TypingBehaviorConfig;
  scrolling?: ScrollBehaviorConfig;
  enabled: boolean;
}

export interface MouseBehaviorConfig {
  speed: number;       // pixels per second
  acceleration: number;
  jitter: number;      // random movement variation
  humanLike: boolean;
}

export interface TypingBehaviorConfig {
  wpm: number;         // words per minute
  errorRate: number;   // 0-1
  rhythm: 'steady' | 'variable';
}

export interface ScrollBehaviorConfig {
  speed: number;
  smoothness: number;
  pauseProbability: number;
}

export interface CookieConfig {
  name: string;
  value: string;
  domain: string;
  path?: string;
  secure?: boolean;
  httpOnly?: boolean;
  sameSite?: 'Strict' | 'Lax' | 'None';
  expirationDate?: number;
}

export interface LocalStorageConfig {
  [key: string]: string;
}

export interface FingerprintQuality {
  score: number;        // 0-100
  issues: string[];
  consistency: boolean;
  entropy: number;
  risk: 'low' | 'medium' | 'high';
  recommendations: string[];
}

// ===== ä½¿ç”¨ç¤ºä¾‹å’Œé›†æˆä»£ç  =====

// main/index.ts é›†æˆç¤ºä¾‹
import { app, BrowserWindow } from 'electron';
import { WindowManager } from './window-manager';
import './ipc-handlers'; // æ³¨å†ŒIPCå¤„ç†å™¨

const windowManager = new WindowManager();

app.whenReady().then(() => {
  // åˆ›å»ºä¸»çª—å£
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, '../preload/index.js'),
      contextIsolation: true,
      nodeIntegration: false
    }
  });

  mainWindow.loadFile('dist/renderer/index.html');

  // ç¤ºä¾‹ï¼šåˆ›å»ºå¸¦æŒ‡çº¹çš„æµè§ˆå™¨å®ä¾‹
  const createExampleAccount = async () => {
    const config: AccountConfig = {
      proxy: 'http://proxy.example.com:8080',
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      fingerprint: {
        canvas: {
          noise: 0.2,
          enabled: true,
          seed: 123456,
          algorithm: 'gaussian'
        },
        webgl: {
          vendor: 'Google Inc. (NVIDIA)',
          renderer: 'ANGLE (NVIDIA, NVIDIA GeForce RTX 3060 Direct3D11 vs_5_0 ps_5_0, D3D11)',
          enabled: true
        },
        audio: {
          noise: 0.1,
          enabled: true,
          seed: 789101
        },
        navigator: {
          platform: 'Win32',
          language: 'en-US',
          languages: ['en-US', 'en'],
          hardwareConcurrency: 8,
          maxTouchPoints: 0,
          deviceMemory: 8,
          enabled: true
        },
        screen: {
          width: 1920,
          height: 1080,
          pixelRatio: 1,
          colorDepth: 24,
          enabled: true
        },
        fonts: {
          available: ['Arial', 'Times New Roman', 'Helvetica', 'Georgia'],
          enabled: true,
          measurementMethod: 'canvas'
        },
        timezone: {
          name: 'America/New_York',
          offset: -300,
          enabled: true
        }
      }
    };

    try {
      const instance = await windowManager.createBrowserInstance('test-account-001', config);
      console.log('Browser instance created:', instance);
    } catch (error) {
      console.error('Failed to create browser instance:', error);
    }
  };

  // å»¶è¿Ÿåˆ›å»ºç¤ºä¾‹è´¦å·
  setTimeout(createExampleAccount, 2000);
});

// ===== preload/index.ts å®Œæ•´æ›´æ–° =====
import { contextBridge, ipcRenderer } from 'electron';
import { injectAllFingerprints, ensureInjected } from './fingerprint';
import { FingerprintConfig, FingerprintQuality } from '../shared/types';

// å…¨å±€å˜é‡ï¼Œç”¨äºå­˜å‚¨æŒ‡çº¹é…ç½®
let globalFingerprintConfig: FingerprintConfig | null = null;

// åœ¨é¡µé¢åŠ è½½å‰æ³¨å…¥æŒ‡çº¹
const injectFingerprints = async () => {
  try {
    // ä»å…¨å±€å˜é‡æˆ–ä¸»è¿›ç¨‹è·å–é…ç½®
    let config = globalFingerprintConfig;
    if (!config) {
      config = await ipcRenderer.invoke('get-fingerprint-config');
    }
    
    if (config) {
      console.log('[Preload] Injecting fingerprints with config:', config);
      ensureInjected(config);
    } else {
      console.warn('[Preload] No fingerprint config available');
    }
  } catch (error) {
    console.error('[Preload] Error injecting fingerprints:', error);
  }
};

// ç›‘å¬é…ç½®æ›´æ–°
ipcRenderer.on('fingerprint-config-updated', (event, config: FingerprintConfig) => {
  globalFingerprintConfig = config;
  console.log('[Preload] Fingerprint config updated:', config);
});

// ç«‹å³æ‰§è¡Œæ³¨å…¥ï¼ˆé’ˆå¯¹å·²ç»åŠ è½½çš„é¡µé¢ï¼‰
injectFingerprints();

// ç›‘å¬DOMåŠ è½½äº‹ä»¶
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', injectFingerprints);
} else {
  injectFingerprints();
}

// æš´éœ²APIç»™æ¸²æŸ“è¿›ç¨‹
contextBridge.exposeInMainWorld('electronAPI', {
  // è´¦å·ç®¡ç†
  createAccount: (account: BrowserAccount) => 
    ipcRenderer.invoke('create-account', account),
  getAccounts: () => 
    ipcRenderer.invoke('get-accounts'),
  deleteAccount: (accountId: string) => 
    ipcRenderer.invoke('delete-account', accountId),
  
  // æµè§ˆå™¨å®ä¾‹ç®¡ç†
  createBrowserInstance: (accountId: string, config: AccountConfig) =>
    ipcRenderer.invoke('create-browser-instance', accountId, config),
  closeBrowserInstance: (accountId: string) =>
    ipcRenderer.invoke('close-browser-instance', accountId),
  getBrowserInstances: () =>
    ipcRenderer.invoke('get-browser-instances'),
  
  // æŒ‡çº¹ç®¡ç†
  getFingerprintConfig: () => 
    ipcRenderer.invoke('get-fingerprint-config'),
  updateFingerprintConfig: (config: FingerprintConfig) => 
    ipcRenderer.invoke('update-fingerprint-config', config),
  validateFingerprint: (config: FingerprintConfig) =>
    ipcRenderer.invoke('validate-fingerprint', config),
  generateFingerprint: (seed?: string) =>
    ipcRenderer.invoke('generate-fingerprint', seed),
  
  // æŒ‡çº¹æµ‹è¯•å’ŒéªŒè¯
  testFingerprint: (url: string) =>
    ipcRenderer.invoke('test-fingerprint', url),
  getFingerprintQuality: (accountId: string) =>
    ipcRenderer.invoke('get-fingerprint-quality', accountId),
  
  // äº‹ä»¶ç›‘å¬
  onFingerprintUpdated: (callback: (config: FingerprintConfig) => void) => {
    ipcRenderer.on('fingerprint-config-updated', (event, config) => callback(config));
  },
  
  // å·¥å…·æ–¹æ³•
  openDevTools: (accountId: string) =>
    ipcRenderer.invoke('open-dev-tools', accountId),
  takeScreenshot: (accountId: string) =>
    ipcRenderer.invoke('take-screenshot', accountId),
  
  // ç§»é™¤ç›‘å¬å™¨
  removeAllListeners: (channel: string) =>
    ipcRenderer.removeAllListeners(channel)
});

// ===== main/ipc-handlers.ts å®Œæ•´æ›´æ–° =====
import { ipcMain, BrowserWindow } from 'electron';
import { WindowManager } from './window-manager';
import { FingerprintGenerator } from './fingerprint/generator';
import { FingerprintValidator } from './fingerprint/validator';
import { AccountStorage } from './storage/account-storage';
import { FingerprintConfig, BrowserAccount, AccountConfig } from '../shared/types';

const windowManager = new WindowManager();
const accountStorage = new AccountStorage();

// è´¦å·ç®¡ç†
ipcMain.handle('create-account', async (event, account: BrowserAccount) => {
  try {
    // å¦‚æœæ²¡æœ‰æŒ‡çº¹é…ç½®ï¼Œè‡ªåŠ¨ç”Ÿæˆ
    if (!account.config?.fingerprint) {
      const fingerprint = FingerprintGenerator.generateFingerprint(account.id);
      account.config = { ...account.config, fingerprint };
    }
    
    await accountStorage.saveAccount(account);
    return { success: true, account };
  } catch (error) {
    console.error('Failed to create account:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('get-accounts', async () => {
  try {
    const accounts = await accountStorage.getAllAccounts();
    return { success: true, accounts };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('delete-account', async (event, accountId: string) => {
  try {
    // å…ˆå…³é—­æµè§ˆå™¨å®ä¾‹
    await windowManager.closeInstance(accountId);
    await accountStorage.deleteAccount(accountId);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// æµè§ˆå™¨å®ä¾‹ç®¡ç†
ipcMain.handle('create-browser-instance', async (event, accountId: string, config: AccountConfig) => {
  try {
    const instance = await windowManager.createBrowserInstance(accountId, config);
    return { success: true, instance };
  } catch (error) {
    console.error('Failed to create browser instance:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('close-browser-instance', async (event, accountId: string) => {
  try {
    await windowManager.closeInstance(accountId);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('get-browser-instances', async () => {
  try {
    const instances = windowManager.getAllInstances();
    return { success: true, instances };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// æŒ‡çº¹ç®¡ç†
ipcMain.handle('get-fingerprint-config', async (event) => {
  const webContents = event.sender;
  const window = BrowserWindow.fromWebContents(webContents);
  
  // é€šè¿‡çª—å£IDæ‰¾åˆ°å¯¹åº”çš„è´¦å·
  for (const instance of windowManager.getAllInstances()) {
    if (instance.windowId === window?.id) {
      const config = windowManager.getFingerprintConfig(instance.accountId);
      return { success: true, config };
    }
  }
  
  return { success: false, error: 'No fingerprint config found' };
});

ipcMain.handle('update-fingerprint-config', async (event, config: FingerprintConfig) => {
  const webContents = event.sender;
  const window = BrowserWindow.fromWebContents(webContents);
  
  for (const instance of windowManager.getAllInstances()) {
    if (instance.windowId === window?.id) {
      windowManager.updateFingerprintConfig(instance.accountId, config);
      
      // é€šçŸ¥æ‰€æœ‰ç›¸å…³çª—å£é…ç½®å·²æ›´æ–°
      webContents.send('fingerprint-config-updated', config);
      
      return { success: true };
    }
  }
  
  return { success: false, error: 'Failed to update fingerprint config' };
});

ipcMain.handle('validate-fingerprint', async (event, config: FingerprintConfig) => {
  try {
    const quality = FingerprintValidator.validateFingerprint(config);
    return { success: true, quality };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('generate-fingerprint', async (event, seed?: string) => {
  try {
    const config = FingerprintGenerator.generateFingerprint(seed);
    const quality = FingerprintValidator.validateFingerprint(config);
    return { success: true, config, quality };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// æŒ‡çº¹æµ‹è¯•
ipcMain.handle('test-fingerprint', async (event, url: string) => {
  try {
    const webContents = event.sender;
    const window = BrowserWindow.fromWebContents(webContents);
    
    if (window) {
      await window.loadURL(url);
      return { success: true };
    }
    
    return { success: false, error: 'Window not found' };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('get-fingerprint-quality', async (event, accountId: string) => {
  try {
    const config = windowManager.getFingerprintConfig(accountId);
    if (config) {
      const quality = FingerprintValidator.validateFingerprint(config);
      return { success: true, quality };
    }
    return { success: false, error: 'No fingerprint config found' };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// å·¥å…·æ–¹æ³•
ipcMain.handle('open-dev-tools', async (event, accountId: string) => {
  try {
    const instance = windowManager.getInstance(accountId);
    if (instance) {
      const window = BrowserWindow.fromId(instance.windowId);
      if (window && !window.isDestroyed()) {
        window.webContents.openDevTools();
        return { success: true };
      }
    }
    return { success: false, error: 'Browser instance not found' };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('take-screenshot', async (event, accountId: string) => {
  try {
    const instance = windowManager.getInstance(accountId);
    if (instance) {
      const window = BrowserWindow.fromId(instance.windowId);
      if (window && !window.isDestroyed()) {
        const image = await window.capturePage();
        const buffer = image.toPNG();
        return { success: true, screenshot: buffer.toString('base64') };
      }
    }
    return { success: false, error: 'Browser instance not found' };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// ===== main/storage/account-storage.ts =====
import * as fs from 'fs/promises';
import * as path from 'path';
import { app } from 'electron';
import { BrowserAccount } from '../../shared/types';

export class AccountStorage {
  private readonly storageDir: string;
  private readonly accountsFile: string;

  constructor() {
    this.storageDir = path.join(app.getPath('userData'), 'accounts');
    this.accountsFile = path.join(this.storageDir, 'accounts.json');
    this.ensureStorageDir();
  }

  private async ensureStorageDir() {
    try {
      await fs.mkdir(this.storageDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create storage directory:', error);
    }
  }

  async saveAccount(account: BrowserAccount): Promise<void> {
    try {
      const accounts = await this.getAllAccounts();
      const existingIndex = accounts.findIndex(a => a.id === account.id);
      
      if (existingIndex >= 0) {
        accounts[existingIndex] = account;
      } else {
        accounts.push(account);
      }
      
      await fs.writeFile(this.accountsFile, JSON.stringify(accounts, null, 2));
    } catch (error) {
      console.error('Failed to save account:', error);
      throw error;
    }
  }

  async getAllAccounts(): Promise<BrowserAccount[]> {
    try {
      const data = await fs.readFile(this.accountsFile, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      if (error.code === 'ENOENT') {
        return []; // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºæ•°ç»„
      }
      console.error('Failed to load accounts:', error);
      throw error;
    }
  }

  async getAccount(accountId: string): Promise<BrowserAccount | null> {
    try {
      const accounts = await this.getAllAccounts();
      return accounts.find(a => a.id === accountId) || null;
    } catch (error) {
      console.error('Failed to get account:', error);
      return null;
    }
  }

  async deleteAccount(accountId: string): Promise<void> {
    try {
      const accounts = await this.getAllAccounts();
      const filteredAccounts = accounts.filter(a => a.id !== accountId);
      await fs.writeFile(this.accountsFile, JSON.stringify(filteredAccounts, null, 2));
    } catch (error) {
      console.error('Failed to delete account:', error);
      throw error;
    }
  }
}

// ===== æµ‹è¯•å’ŒéªŒè¯å·¥å…· =====

export class FingerprintTester {
  static readonly TEST_URLS = {
    canvas: 'https://browserleaks.com/canvas',
    webgl: 'https://browserleaks.com/webgl',
    audio: 'https://browserleaks.com/audio',
    fonts: 'https://browserleaks.com/fonts',
    general: 'https://amiunique.org/fingerprint',
    comprehensive: 'https://coveryourtracks.eff.org/'
  };

  static async runFingerprintTest(windowManager: WindowManager, accountId: string): Promise<any> {
    const instance = windowManager.getInstance(accountId);
    if (!instance) {
      throw new Error('Browser instance not found');
    }

    const window = BrowserWindow.fromId(instance.windowId);
    if (!window || window.isDestroyed()) {
      throw new Error('Browser window not available');
    }

    const results = {};

    // æµ‹è¯•å„ä¸ªæŒ‡çº¹ç»„ä»¶
    for (const [name, url] of Object.entries(this.TEST_URLS)) {
      try {
        console.log(`Testing ${name} fingerprint at ${url}`);
        await window.loadURL(url);
        
        // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
        await new Promise(resolve => {
          window.webContents.once('did-finish-load', resolve);
        });

        // æ‰§è¡Œç‰¹å®šçš„æµ‹è¯•è„šæœ¬
        const result = await this.executeTestScript(window.webContents, name);
        results[name] = result;
        
        // çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡å¿«
        await new Promise(resolve => setTimeout(resolve, 2000));
      } catch (error) {
        console.error(`Failed to test ${name}:`, error);
        results[name] = { error: error.message };
      }
    }

    return results;
  }

  private static async executeTestScript(webContents: any, testType: string): Promise<any> {
    switch (testType) {
      case 'canvas':
        return await webContents.executeJavaScript(`
          (function() {
            try {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              ctx.textBaseline = 'top';
              ctx.font = '14px Arial';
              ctx.fillText('Browser fingerprint test ğŸ¨', 2, 2);
              return {
                dataURL: canvas.toDataURL(),
                width: canvas.width,
                height: canvas.height
              };
            } catch (e) {
              return { error: e.message };
            }
          })();
        `);

      case 'webgl':
        return await webContents.executeJavaScript(`
          (function() {
            try {
              const canvas = document.createElement('canvas');
              const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
              if (!gl) return { error: 'WebGL not supported' };
              
              return {
                vendor: gl.getParameter(gl.VENDOR),
                renderer: gl.getParameter(gl.RENDERER),
                version: gl.getParameter(gl.VERSION),
                shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
              };
            } catch (e) {
              return { error: e.message };
            }
          })();
        `);

      case 'audio':
        return await webContents.executeJavaScript(`
          (function() {
            try {
              const AudioContext = window.AudioContext || window.webkitAudioContext;
              if (!AudioContext) return { error: 'AudioContext not supported' };
              
              const context = new AudioContext();
              return {
                sampleRate: context.sampleRate,
                state: context.state,
                maxChannelCount: context.destination.maxChannelCount
              };
            } catch (e) {
              return { error: e.message };
            }
          })();
        `);

      default:
        return { message: 'Generic fingerprint test completed' };
    }
  }
}

// ===== æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ– =====

export class FingerprintPerformanceProfiler {
  private static metrics = new Map<string, number[]>();
  
  static startProfiler(operation: string): string {
    const id = `${operation}-${Date.now()}-${Math.random()}`;
    performance.mark(`${id}-start`);
    return id;
  }
  
  static endProfiler(id: string): number {
    try {
      performance.mark(`${id}-end`);
      performance.measure(id, `${id}-start`, `${id}-end`);
      
      const measure = performance.getEntriesByName(id)[0];
      const duration = measure.duration;
      
      // è®°å½•æ€§èƒ½æŒ‡æ ‡
      const operation = id.split('-')[0];
      if (!this.metrics.has(operation)) {
        this.metrics.set(operation, []);
      }
      this.metrics.get(operation)!.push(duration);
      
      // æ¸…ç†æ€§èƒ½æ ‡è®°
      performance.clearMarks(`${id}-start`);
      performance.clearMarks(`${id}-end`);
      performance.clearMeasures(id);
      
      return duration;
    } catch (error) {
      console.error('Performance profiler error:', error);
      return -1;
    }
  }
  
  static getMetrics(): Record<string, { avg: number; min: number; max: number; count: number }> {
    const result = {};
    
    for (const [operation, durations] of this.metrics.entries()) {
      if (durations.length > 0) {
        result[operation] = {
          avg: durations.reduce((a, b) => a + b, 0) / durations.length,
          min: Math.min(...durations),
          max: Math.max(...durations),
          count: durations.length
        };
      }
    }
    
    return result;
  }
  
  static clearMetrics(): void {
    this.metrics.clear();
  }
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====

/*
// åœ¨ renderer/App.tsx ä¸­ä½¿ç”¨æŒ‡çº¹é…ç½®ç»„ä»¶

import React, { useState, useEffect } from 'react';
import { FingerprintConfigComponent } from './components/FingerprintConfig';
import { BrowserAccount } from '../shared/types';

export const App: React.FC = () => {
  const [accounts, setAccounts] = useState<BrowserAccount[]>([]);
  const [selectedAccount, setSelectedAccount] = useState<string | null>(null);

  useEffect(() => {
    loadAccounts();
  }, []);

  const loadAccounts = async () => {
    try {
      const result = await window.electronAPI.getAccounts();
      if (result.success) {
        setAccounts(result.accounts);
      }
    } catch (error) {
      console.error('Failed to load accounts:', error);
    }
  };

  const createAccount = async () => {
    const account: BrowserAccount = {
      id: `account-${Date.now()}`,
      name: `Account ${accounts.length + 1}`,
      status: 'idle',
      createdAt: Date.now()
    };

    try {
      const result = await window.electronAPI.createAccount(account);
      if (result.success) {
        setAccounts([...accounts, result.account]);
      }
    } catch (error) {
      console.error('Failed to create account:', error);
    }
  };

  const launchBrowser = async (accountId: string) => {
    try {
      const result = await window.electronAPI.createBrowserInstance(accountId, {});
      if (result.success) {
        console.log('Browser launched:', result.instance);
      }
    } catch (error) {
      console.error('Failed to launch browser:', error);
    }
  };

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-6">é˜²å…³è”æµè§ˆå™¨</h1>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div>
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-semibold">è´¦å·ç®¡ç†</h2>
            <button
              onClick={createAccount}
              className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
            >
              åˆ›å»ºè´¦å·
            </button>
          </div>
          
          <div className="space-y-2">
            {accounts.map(account => (
              <div key={account.id} className="flex items-center justify-between p-3 border rounded">
                <div>
                  <span className="font-medium">{account.name}</span>
                  <span className={`ml-2 px-2 py-1 text-xs rounded ${
                    account.status === 'running' ? 'bg-green-100 text-green-800' :
                    account.status === 'error' ? 'bg-red-100 text-red-800' :
                    'bg-gray-100 text-gray-800'
                  }`}>
                    {account.status}
                  </span>
                </div>
                <div className="flex space-x-2">
                  <button
                    onClick={() => setSelectedAccount(account.id)}
                    className="text-blue-600 hover:text-blue-800"
                  >
                    é…ç½®
                  </button>
                  <button
                    onClick={() => launchBrowser(account.id)}
                    className="text-green-600 hover:text-green-800"
                  >
                    å¯åŠ¨
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
        
        <div>
          {selectedAccount && (
            <FingerprintConfigComponent
              accountId={selectedAccount}
              onConfigChange={(config) => {
                console.log('Fingerprint config updated:', config);
              }}
            />
          )}
        </div>
      </div>
    </div>
  );
};

*/

// ===== éƒ¨ç½²å’Œæµ‹è¯•æ¸…å• =====

/*
## éƒ¨ç½²æ­¥éª¤

1. å®‰è£…ä¾èµ–ï¼ˆå¦‚æœéœ€è¦ï¼‰
   npm install crypto-js uuid

2. æ›´æ–° package.json è„šæœ¬
   {
     "scripts": {
       "dev": "concurrently \"npm run dev:main\" \"npm run dev:renderer\"",
       "dev:main": "tsc -p tsconfig.main.json && electron dist/main/index.js",
       "dev:renderer": "vite",
       "build": "npm run build:main && npm run build:renderer",
       "build:main": "tsc -p tsconfig.main.json",
       "build:renderer": "vite build",
       "test:fingerprint": "node scripts/test-fingerprint.js"
     }
   }

3. åˆ›å»ºæµ‹è¯•è„šæœ¬ scripts/test-fingerprint.js
   const { FingerprintTester } = require('../dist/main/fingerprint/tester');
   
   async function runTests() {
     console.log('Running fingerprint tests...');
     // æµ‹è¯•é€»è¾‘
   }
   
   runTests().catch(console.error);

## éªŒæ”¶æµ‹è¯•æ¸…å•

â–¡ åŸºç¡€åŠŸèƒ½æµ‹è¯•
  â–¡ åˆ›å»ºè´¦å·å¹¶è‡ªåŠ¨ç”ŸæˆæŒ‡çº¹é…ç½®
  â–¡ å¯åŠ¨æµè§ˆå™¨å®ä¾‹å¹¶åŠ è½½æŒ‡çº¹
  â–¡ é…ç½®ä¿å­˜å’ŒåŠ è½½æ­£å¸¸
  â–¡ çª—å£å…³é—­æ—¶æ¸…ç†èµ„æº

â–¡ æŒ‡çº¹ä¸€è‡´æ€§æµ‹è¯•
  â–¡ åŒä¸€è´¦å·å¤šæ¬¡è®¿é—®åŒä¸€ç½‘ç«™ï¼ŒæŒ‡çº¹ä¿æŒä¸€è‡´
  â–¡ ä¸åŒè´¦å·è®¿é—®åŒä¸€ç½‘ç«™ï¼Œæ˜¾ç¤ºä¸åŒæŒ‡çº¹
  â–¡ é‡å¯åº”ç”¨åæŒ‡çº¹é…ç½®ä¿æŒä¸å˜

â–¡ æŒ‡çº¹è´¨é‡æµ‹è¯•
  â–¡ Canvas æŒ‡çº¹ï¼šhttps://browserleaks.com/canvas
  â–¡ WebGL æŒ‡çº¹ï¼šhttps://browserleaks.com/webgl
  â–¡ Audio æŒ‡çº¹ï¼šhttps://amiunique.org/fingerprint
  â–¡ Navigator æŒ‡çº¹ï¼šæ£€æŸ¥å¹³å°ã€è¯­è¨€ã€CPUæ ¸å¿ƒæ•°ç­‰
  â–¡ ç»¼åˆæµ‹è¯•ï¼šhttps://coveryourtracks.eff.org/

â–¡ æ€§èƒ½æµ‹è¯•
  â–¡ åº”ç”¨å¯åŠ¨æ—¶é—´ < 5ç§’
  â–¡ åˆ›å»ºæµè§ˆå™¨å®ä¾‹æ—¶é—´ < 3ç§’
  â–¡ æŒ‡çº¹æ³¨å…¥æ—¶é—´ < 100ms
  â–¡ é¡µé¢åŠ è½½æ€§èƒ½å½±å“ < 5%

â–¡ ç¨³å®šæ€§æµ‹è¯•
  â–¡ é•¿æ—¶é—´è¿è¡Œæ— å†…å­˜æ³„æ¼
  â–¡ å¤§é‡è´¦å·åˆ›å»ºå’Œåˆ é™¤
  â–¡ å¼‚å¸¸æƒ…å†µå¤„ç†ï¼ˆç½‘ç»œä¸­æ–­ã€ä»£ç†å¤±æ•ˆç­‰ï¼‰

â–¡ åæ£€æµ‹æµ‹è¯•
  â–¡ é€šè¿‡å¸¸è§çš„æœºå™¨äººæ£€æµ‹
  â–¡ WebDriver å±æ€§æ­£ç¡®éšè—
  â–¡ æŒ‡çº¹ç†µå€¼åœ¨åˆç†èŒƒå›´å†…

## å¸¸è§é—®é¢˜è§£å†³

1. æŒ‡çº¹æ³¨å…¥å¤±è´¥
   - æ£€æŸ¥ preload è„šæœ¬è·¯å¾„
   - ç¡®è®¤ contextIsolation è®¾ç½®
   - æŸ¥çœ‹æ§åˆ¶å°é”™è¯¯ä¿¡æ¯

2. æ€§èƒ½é—®é¢˜
   - å‡å°‘å™ªå£°æ³¨å…¥é¢‘ç‡
   - ä¼˜åŒ–å­—ä½“æ£€æµ‹ç®—æ³•
   - ä½¿ç”¨ Web Worker å¤„ç†è€—æ—¶æ“ä½œ

3. åæ£€æµ‹å¤±è´¥
   - æ›´æ–° GPU å’Œ UserAgent æ•°æ®åº“
   - è°ƒæ•´æŒ‡çº¹å‚æ•°èŒƒå›´
   - å¢åŠ è¡Œä¸ºæ¨¡æ‹ŸåŠŸèƒ½

4. å†…å­˜æ³„æ¼
   - åŠæ—¶æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
   - æ­£ç¡®å¤„ç† BrowserWindow ç”Ÿå‘½å‘¨æœŸ
   - å®šæœŸæ£€æŸ¥å¯¹è±¡å¼•ç”¨

*/